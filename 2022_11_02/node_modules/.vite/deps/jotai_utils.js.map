{
  "version": 3,
  "sources": ["../../jotai/esm/utils.mjs"],
  "sourcesContent": ["import { atom, SECRET_INTERNAL_getScopeContext, useAtom, useSetAtom, SECRET_INTERNAL_registerPromiseAbort } from 'jotai';\nexport { useAtomValue, useSetAtom as useUpdateAtom } from 'jotai';\nimport { useContext, useCallback, useMemo } from 'react';\n\nconst RESET = Symbol();\n\nfunction atomWithReset(initialValue) {\n  const anAtom = atom(initialValue, (get, set, update) => {\n    const nextValue = typeof update === \"function\" ? update(get(anAtom)) : update;\n    set(anAtom, nextValue === RESET ? initialValue : nextValue);\n  });\n  return anAtom;\n}\n\nconst WRITE_ATOM = \"w\";\nconst RESTORE_ATOMS = \"h\";\n\nfunction useResetAtom(anAtom, scope) {\n  const ScopeContext = SECRET_INTERNAL_getScopeContext(scope);\n  const store = useContext(ScopeContext).s;\n  const setAtom = useCallback(\n    () => store[WRITE_ATOM](anAtom, RESET),\n    [store, anAtom]\n  );\n  return setAtom;\n}\n\nfunction useReducerAtom(anAtom, reducer, scope) {\n  const [state, setState] = useAtom(anAtom, scope);\n  const dispatch = useCallback(\n    (action) => {\n      setState((prev) => reducer(prev, action));\n    },\n    [setState, reducer]\n  );\n  return [state, dispatch];\n}\n\nfunction atomWithReducer(initialValue, reducer) {\n  const anAtom = atom(\n    initialValue,\n    (get, set, action) => set(anAtom, reducer(get(anAtom), action))\n  );\n  return anAtom;\n}\n\nfunction atomFamily(initializeAtom, areEqual) {\n  let shouldRemove = null;\n  const atoms = /* @__PURE__ */ new Map();\n  const createAtom = (param) => {\n    let item;\n    if (areEqual === void 0) {\n      item = atoms.get(param);\n    } else {\n      for (const [key, value] of atoms) {\n        if (areEqual(key, param)) {\n          item = value;\n          break;\n        }\n      }\n    }\n    if (item !== void 0) {\n      if (shouldRemove == null ? void 0 : shouldRemove(item[1], param)) {\n        createAtom.remove(param);\n      } else {\n        return item[0];\n      }\n    }\n    const newAtom = initializeAtom(param);\n    atoms.set(param, [newAtom, Date.now()]);\n    return newAtom;\n  };\n  createAtom.remove = (param) => {\n    if (areEqual === void 0) {\n      atoms.delete(param);\n    } else {\n      for (const [key] of atoms) {\n        if (areEqual(key, param)) {\n          atoms.delete(key);\n          break;\n        }\n      }\n    }\n  };\n  createAtom.setShouldRemove = (fn) => {\n    shouldRemove = fn;\n    if (!shouldRemove)\n      return;\n    for (const [key, value] of atoms) {\n      if (shouldRemove(value[1], key)) {\n        atoms.delete(key);\n      }\n    }\n  };\n  return createAtom;\n}\n\nconst getWeakCacheItem = (cache, deps) => {\n  do {\n    const [dep, ...rest] = deps;\n    const entry = cache.get(dep);\n    if (!entry) {\n      return;\n    }\n    if (!rest.length) {\n      return entry[1];\n    }\n    cache = entry[0];\n    deps = rest;\n  } while (deps.length);\n};\nconst setWeakCacheItem = (cache, deps, item) => {\n  do {\n    const [dep, ...rest] = deps;\n    let entry = cache.get(dep);\n    if (!entry) {\n      entry = [ new WeakMap()];\n      cache.set(dep, entry);\n    }\n    if (!rest.length) {\n      entry[1] = item;\n      return;\n    }\n    cache = entry[0];\n    deps = rest;\n  } while (deps.length);\n};\nconst createMemoizeAtom = () => {\n  const cache = /* @__PURE__ */ new WeakMap();\n  const memoizeAtom = (createAtom, deps) => {\n    const cachedAtom = getWeakCacheItem(cache, deps);\n    if (cachedAtom) {\n      return cachedAtom;\n    }\n    const createdAtom = createAtom();\n    setWeakCacheItem(cache, deps, createdAtom);\n    return createdAtom;\n  };\n  return memoizeAtom;\n};\n\nconst memoizeAtom$4 = createMemoizeAtom();\nfunction selectAtom(anAtom, selector, equalityFn = Object.is) {\n  return memoizeAtom$4(() => {\n    const refAtom = atom(() => ({}));\n    const derivedAtom = atom((get) => {\n      const slice = selector(get(anAtom));\n      const ref = get(refAtom);\n      if (\"prev\" in ref && equalityFn(ref.prev, slice)) {\n        return ref.prev;\n      }\n      ref.prev = slice;\n      return slice;\n    });\n    return derivedAtom;\n  }, [anAtom, selector, equalityFn]);\n}\n\nfunction useAtomCallback(callback, scope) {\n  const anAtom = useMemo(\n    () => atom(\n      null,\n      (get, set, [arg, resolve, reject]) => {\n        try {\n          resolve(callback(get, set, arg));\n        } catch (e) {\n          reject(e);\n        }\n      }\n    ),\n    [callback]\n  );\n  const invoke = useSetAtom(anAtom, scope);\n  return useCallback(\n    (arg) => {\n      let isSync = true;\n      let settled = {};\n      const promise = new Promise((resolve, reject) => {\n        invoke([\n          arg,\n          (v) => {\n            if (isSync) {\n              settled = { v };\n            } else {\n              resolve(v);\n            }\n          },\n          (e) => {\n            if (isSync) {\n              settled = { e };\n            } else {\n              reject(e);\n            }\n          }\n        ]);\n      });\n      isSync = false;\n      if (\"e\" in settled) {\n        throw settled.e;\n      }\n      if (\"v\" in settled) {\n        return settled.v;\n      }\n      return promise;\n    },\n    [invoke]\n  );\n}\n\nconst memoizeAtom$3 = createMemoizeAtom();\nconst deepFreeze = (obj) => {\n  if (typeof obj !== \"object\" || obj === null)\n    return;\n  Object.freeze(obj);\n  const propNames = Object.getOwnPropertyNames(obj);\n  for (const name of propNames) {\n    const value = obj[name];\n    deepFreeze(value);\n  }\n  return obj;\n};\nfunction freezeAtom(anAtom) {\n  return memoizeAtom$3(() => {\n    const frozenAtom = atom(\n      (get) => deepFreeze(get(anAtom)),\n      (_get, set, arg) => set(anAtom, arg)\n    );\n    return frozenAtom;\n  }, [anAtom]);\n}\nfunction freezeAtomCreator(createAtom) {\n  return (...params) => {\n    const anAtom = createAtom(...params);\n    const origRead = anAtom.read;\n    anAtom.read = (get) => deepFreeze(origRead(get));\n    return anAtom;\n  };\n}\n\nconst memoizeAtom$2 = createMemoizeAtom();\nconst isWritable = (atom2) => !!atom2.write;\nconst isFunction = (x) => typeof x === \"function\";\nfunction splitAtom(arrAtom, keyExtractor) {\n  return memoizeAtom$2(\n    () => {\n      const mappingCache = /* @__PURE__ */ new WeakMap();\n      const getMapping = (arr, prev) => {\n        let mapping = mappingCache.get(arr);\n        if (mapping) {\n          return mapping;\n        }\n        const prevMapping = prev && mappingCache.get(prev);\n        const atomList = [];\n        const keyList = [];\n        arr.forEach((item, index) => {\n          const key = keyExtractor ? keyExtractor(item) : index;\n          keyList[index] = key;\n          const cachedAtom = prevMapping && prevMapping.atomList[prevMapping.keyList.indexOf(key)];\n          if (cachedAtom) {\n            atomList[index] = cachedAtom;\n            return;\n          }\n          const read2 = (get) => {\n            const ref = get(refAtom);\n            const currArr = get(arrAtom);\n            const mapping2 = getMapping(currArr, ref.prev);\n            const index2 = mapping2.keyList.indexOf(key);\n            if (index2 < 0 || index2 >= currArr.length) {\n              const prevItem = arr[getMapping(arr).keyList.indexOf(key)];\n              if (prevItem) {\n                return prevItem;\n              }\n              throw new Error(\"splitAtom: index out of bounds for read\");\n            }\n            return currArr[index2];\n          };\n          const write2 = (get, set, update) => {\n            const ref = get(refAtom);\n            const arr2 = get(arrAtom);\n            const mapping2 = getMapping(arr2, ref.prev);\n            const index2 = mapping2.keyList.indexOf(key);\n            if (index2 < 0 || index2 >= arr2.length) {\n              throw new Error(\"splitAtom: index out of bounds for write\");\n            }\n            const nextItem = isFunction(update) ? update(arr2[index2]) : update;\n            set(arrAtom, [\n              ...arr2.slice(0, index2),\n              nextItem,\n              ...arr2.slice(index2 + 1)\n            ]);\n          };\n          atomList[index] = isWritable(arrAtom) ? atom(read2, write2) : atom(read2);\n        });\n        if (prevMapping && prevMapping.keyList.length === keyList.length && prevMapping.keyList.every((x, i) => x === keyList[i])) {\n          mapping = prevMapping;\n        } else {\n          mapping = { atomList, keyList };\n        }\n        mappingCache.set(arr, mapping);\n        return mapping;\n      };\n      const refAtom = atom(() => ({}));\n      const read = (get) => {\n        const ref = get(refAtom);\n        const arr = get(arrAtom);\n        const mapping = getMapping(arr, ref.prev);\n        ref.prev = arr;\n        return mapping.atomList;\n      };\n      const write = (get, set, action) => {\n        if (\"read\" in action) {\n          console.warn(\"atomToRemove is deprecated. use action with type\");\n          action = { type: \"remove\", atom: action };\n        }\n        switch (action.type) {\n          case \"remove\": {\n            const index = get(splittedAtom).indexOf(action.atom);\n            if (index >= 0) {\n              const arr = get(arrAtom);\n              set(arrAtom, [\n                ...arr.slice(0, index),\n                ...arr.slice(index + 1)\n              ]);\n            }\n            break;\n          }\n          case \"insert\": {\n            const index = action.before ? get(splittedAtom).indexOf(action.before) : get(splittedAtom).length;\n            if (index >= 0) {\n              const arr = get(arrAtom);\n              set(arrAtom, [\n                ...arr.slice(0, index),\n                action.value,\n                ...arr.slice(index)\n              ]);\n            }\n            break;\n          }\n          case \"move\": {\n            const index1 = get(splittedAtom).indexOf(action.atom);\n            const index2 = action.before ? get(splittedAtom).indexOf(action.before) : get(splittedAtom).length;\n            if (index1 >= 0 && index2 >= 0) {\n              const arr = get(arrAtom);\n              if (index1 < index2) {\n                set(arrAtom, [\n                  ...arr.slice(0, index1),\n                  ...arr.slice(index1 + 1, index2),\n                  arr[index1],\n                  ...arr.slice(index2)\n                ]);\n              } else {\n                set(arrAtom, [\n                  ...arr.slice(0, index2),\n                  arr[index1],\n                  ...arr.slice(index2, index1),\n                  ...arr.slice(index1 + 1)\n                ]);\n              }\n            }\n            break;\n          }\n        }\n      };\n      const splittedAtom = isWritable(arrAtom) ? atom(read, write) : atom(read);\n      return splittedAtom;\n    },\n    keyExtractor ? [arrAtom, keyExtractor] : [arrAtom]\n  );\n}\n\nfunction atomWithDefault(getDefault) {\n  const EMPTY = Symbol();\n  const overwrittenAtom = atom(EMPTY);\n  const anAtom = atom(\n    (get) => {\n      const overwritten = get(overwrittenAtom);\n      if (overwritten !== EMPTY) {\n        return overwritten;\n      }\n      return getDefault(get);\n    },\n    (get, set, update) => {\n      if (update === RESET) {\n        return set(overwrittenAtom, EMPTY);\n      }\n      return set(\n        overwrittenAtom,\n        typeof update === \"function\" ? update(get(anAtom)) : update\n      );\n    }\n  );\n  return anAtom;\n}\n\nconst memoizeAtom$1 = createMemoizeAtom();\nconst emptyArrayAtom = atom(() => []);\nfunction waitForAll(atoms) {\n  const createAtom = () => {\n    const unwrappedAtoms = unwrapAtoms(atoms);\n    const derivedAtom = atom((get) => {\n      const promises = [];\n      const values = unwrappedAtoms.map((anAtom, index) => {\n        try {\n          return get(anAtom);\n        } catch (e) {\n          if (e instanceof Promise) {\n            promises[index] = e;\n          } else {\n            throw e;\n          }\n        }\n      });\n      if (promises.length) {\n        throw Promise.all(promises);\n      }\n      return wrapResults(atoms, values);\n    });\n    return derivedAtom;\n  };\n  if (Array.isArray(atoms)) {\n    if (atoms.length) {\n      return memoizeAtom$1(createAtom, atoms);\n    }\n    return emptyArrayAtom;\n  }\n  return createAtom();\n}\nconst unwrapAtoms = (atoms) => Array.isArray(atoms) ? atoms : Object.getOwnPropertyNames(atoms).map((key) => atoms[key]);\nconst wrapResults = (atoms, results) => Array.isArray(atoms) ? results : Object.getOwnPropertyNames(atoms).reduce(\n  (out, key, idx) => ({ ...out, [key]: results[idx] }),\n  {}\n);\n\nconst NO_STORAGE_VALUE = Symbol();\nfunction createJSONStorage(getStringStorage) {\n  let lastStr;\n  let lastValue;\n  const storage = {\n    getItem: (key) => {\n      var _a, _b;\n      const parse = (str2) => {\n        str2 = str2 || \"\";\n        if (lastStr !== str2) {\n          try {\n            lastValue = JSON.parse(str2);\n          } catch {\n            return NO_STORAGE_VALUE;\n          }\n          lastStr = str2;\n        }\n        return lastValue;\n      };\n      const str = (_b = (_a = getStringStorage()) == null ? void 0 : _a.getItem(key)) != null ? _b : null;\n      if (str instanceof Promise) {\n        return str.then(parse);\n      }\n      return parse(str);\n    },\n    setItem: (key, newValue) => {\n      var _a;\n      return (_a = getStringStorage()) == null ? void 0 : _a.setItem(key, JSON.stringify(newValue));\n    },\n    removeItem: (key) => {\n      var _a;\n      return (_a = getStringStorage()) == null ? void 0 : _a.removeItem(key);\n    }\n  };\n  if (typeof window !== \"undefined\" && typeof window.addEventListener === \"function\") {\n    storage.subscribe = (key, callback) => {\n      const storageEventCallback = (e) => {\n        if (e.key === key && e.newValue) {\n          callback(JSON.parse(e.newValue));\n        }\n      };\n      window.addEventListener(\"storage\", storageEventCallback);\n      return () => {\n        window.removeEventListener(\"storage\", storageEventCallback);\n      };\n    };\n  }\n  return storage;\n}\nconst defaultStorage = createJSONStorage(\n  () => typeof window !== \"undefined\" ? window.localStorage : void 0\n);\nfunction atomWithStorage(key, initialValue, storage = defaultStorage) {\n  const getInitialValue = () => {\n    const value = storage.getItem(key);\n    if (value instanceof Promise) {\n      return value.then((v) => v === NO_STORAGE_VALUE ? initialValue : v);\n    }\n    return value === NO_STORAGE_VALUE ? initialValue : value;\n  };\n  const baseAtom = atom(storage.delayInit ? initialValue : getInitialValue());\n  baseAtom.onMount = (setAtom) => {\n    let unsub;\n    if (storage.subscribe) {\n      unsub = storage.subscribe(key, setAtom);\n      setAtom(getInitialValue());\n    }\n    if (storage.delayInit) {\n      const value = getInitialValue();\n      if (value instanceof Promise) {\n        value.then(setAtom);\n      } else {\n        setAtom(value);\n      }\n    }\n    return unsub;\n  };\n  const anAtom = atom(\n    (get) => get(baseAtom),\n    (get, set, update) => {\n      const nextValue = typeof update === \"function\" ? update(get(baseAtom)) : update;\n      if (nextValue === RESET) {\n        set(baseAtom, initialValue);\n        return storage.removeItem(key);\n      }\n      set(baseAtom, nextValue);\n      return storage.setItem(key, nextValue);\n    }\n  );\n  return anAtom;\n}\nfunction atomWithHash(key, initialValue, options) {\n  const serialize = (options == null ? void 0 : options.serialize) || JSON.stringify;\n  const deserialize = (options == null ? void 0 : options.deserialize) || ((str) => {\n    try {\n      return JSON.parse(str || \"\");\n    } catch {\n      return NO_STORAGE_VALUE;\n    }\n  });\n  const subscribe = (options == null ? void 0 : options.subscribe) || ((callback) => {\n    window.addEventListener(\"hashchange\", callback);\n    return () => {\n      window.removeEventListener(\"hashchange\", callback);\n    };\n  });\n  const hashStorage = {\n    getItem: (key2) => {\n      if (typeof location === \"undefined\") {\n        return NO_STORAGE_VALUE;\n      }\n      const searchParams = new URLSearchParams(location.hash.slice(1));\n      const storedValue = searchParams.get(key2);\n      return deserialize(storedValue);\n    },\n    setItem: (key2, newValue) => {\n      const searchParams = new URLSearchParams(location.hash.slice(1));\n      searchParams.set(key2, serialize(newValue));\n      if (options == null ? void 0 : options.replaceState) {\n        history.replaceState(\n          null,\n          \"\",\n          location.pathname + location.search + \"#\" + searchParams.toString()\n        );\n      } else {\n        location.hash = searchParams.toString();\n      }\n    },\n    removeItem: (key2) => {\n      const searchParams = new URLSearchParams(location.hash.slice(1));\n      searchParams.delete(key2);\n      if (options == null ? void 0 : options.replaceState) {\n        history.replaceState(\n          null,\n          \"\",\n          location.pathname + location.search + \"#\" + searchParams.toString()\n        );\n      } else {\n        location.hash = searchParams.toString();\n      }\n    },\n    ...(options == null ? void 0 : options.delayInit) && { delayInit: true },\n    subscribe: (key2, setValue) => {\n      const callback = () => {\n        const searchParams = new URLSearchParams(location.hash.slice(1));\n        const str = searchParams.get(key2);\n        if (str !== null) {\n          setValue(deserialize(str));\n        } else {\n          setValue(initialValue);\n        }\n      };\n      return subscribe(callback);\n    }\n  };\n  return atomWithStorage(key, initialValue, hashStorage);\n}\n\nfunction atomWithObservable(getObservable, options) {\n  const observableResultAtom = atom((get) => {\n    var _a;\n    let observable = getObservable(get);\n    const itself = (_a = observable[Symbol.observable]) == null ? void 0 : _a.call(observable);\n    if (itself) {\n      observable = itself;\n    }\n    let resolve;\n    const makePending = () => new Promise((r) => {\n      resolve = r;\n    });\n    const initialResult = options && \"initialValue\" in options ? {\n      d: typeof options.initialValue === \"function\" ? options.initialValue() : options.initialValue\n    } : makePending();\n    let setResult;\n    let lastResult;\n    const listener = (result) => {\n      lastResult = result;\n      resolve == null ? void 0 : resolve(result);\n      setResult == null ? void 0 : setResult(result);\n    };\n    let subscription;\n    let timer;\n    const isNotMounted = () => !setResult;\n    const start = () => {\n      if (subscription) {\n        clearTimeout(timer);\n        subscription.unsubscribe();\n      }\n      subscription = observable.subscribe({\n        next: (d) => listener({ d }),\n        error: (e) => listener({ e }),\n        complete: () => {\n        }\n      });\n      if (isNotMounted() && (options == null ? void 0 : options.unstable_timeout)) {\n        timer = setTimeout(() => {\n          if (subscription) {\n            subscription.unsubscribe();\n            subscription = void 0;\n          }\n        }, options.unstable_timeout);\n      }\n    };\n    start();\n    const resultAtom = atom(lastResult || initialResult);\n    resultAtom.onMount = (update) => {\n      setResult = update;\n      if (lastResult) {\n        update(lastResult);\n      }\n      if (subscription) {\n        clearTimeout(timer);\n      } else {\n        start();\n      }\n      return () => {\n        setResult = void 0;\n        if (subscription) {\n          subscription.unsubscribe();\n          subscription = void 0;\n        }\n      };\n    };\n    return [resultAtom, observable, makePending, start, isNotMounted];\n  });\n  const observableAtom = atom(\n    (get) => {\n      const [resultAtom] = get(observableResultAtom);\n      const result = get(resultAtom);\n      if (\"e\" in result) {\n        throw result.e;\n      }\n      return result.d;\n    },\n    (get, set, data) => {\n      const [resultAtom, observable, makePending, start, isNotMounted] = get(observableResultAtom);\n      if (\"next\" in observable) {\n        if (isNotMounted()) {\n          set(resultAtom, makePending());\n          start();\n        }\n        observable.next(data);\n      } else {\n        throw new Error(\"observable is not subject\");\n      }\n    }\n  );\n  return observableAtom;\n}\n\nconst hydratedMap = /* @__PURE__ */ new WeakMap();\nfunction useHydrateAtoms(values, scope) {\n  const ScopeContext = SECRET_INTERNAL_getScopeContext(scope);\n  const scopeContainer = useContext(ScopeContext);\n  const store = scopeContainer.s;\n  const hydratedSet = getHydratedSet(scopeContainer);\n  const tuplesToRestore = [];\n  for (const tuple of values) {\n    const atom = tuple[0];\n    if (!hydratedSet.has(atom)) {\n      hydratedSet.add(atom);\n      tuplesToRestore.push(tuple);\n    }\n  }\n  if (tuplesToRestore.length) {\n    store[RESTORE_ATOMS](tuplesToRestore);\n  }\n}\nfunction getHydratedSet(scopeContainer) {\n  let hydratedSet = hydratedMap.get(scopeContainer);\n  if (!hydratedSet) {\n    hydratedSet = /* @__PURE__ */ new WeakSet();\n    hydratedMap.set(scopeContainer, hydratedSet);\n  }\n  return hydratedSet;\n}\n\nconst memoizeAtom = createMemoizeAtom();\nconst LOADING = { state: \"loading\" };\nfunction loadable(anAtom) {\n  return memoizeAtom(() => {\n    const loadableAtomCache = /* @__PURE__ */ new WeakMap();\n    const catchAtom = atom((get) => {\n      let promise;\n      try {\n        const data = get(anAtom);\n        const loadableAtom2 = atom({ state: \"hasData\", data });\n        return loadableAtom2;\n      } catch (error) {\n        if (error instanceof Promise) {\n          promise = error;\n        } else {\n          const loadableAtom2 = atom({\n            state: \"hasError\",\n            error\n          });\n          return loadableAtom2;\n        }\n      }\n      const cached = loadableAtomCache.get(promise);\n      if (cached) {\n        return cached;\n      }\n      const loadableAtom = atom(\n        LOADING,\n        async (get2, set) => {\n          try {\n            const data = await get2(anAtom, { unstable_promise: true });\n            set(loadableAtom, { state: \"hasData\", data });\n          } catch (error) {\n            set(loadableAtom, { state: \"hasError\", error });\n          }\n        }\n      );\n      loadableAtom.onMount = (init) => {\n        init();\n      };\n      loadableAtomCache.set(promise, loadableAtom);\n      return loadableAtom;\n    });\n    const derivedAtom = atom((get) => {\n      const loadableAtom = get(catchAtom);\n      return get(loadableAtom);\n    });\n    return derivedAtom;\n  }, [anAtom]);\n}\n\nfunction abortableAtom(read, write) {\n  return atom((get) => {\n    const controller = new AbortController();\n    const promise = read(get, { signal: controller.signal });\n    if (promise instanceof Promise) {\n      SECRET_INTERNAL_registerPromiseAbort(promise, () => controller.abort());\n    }\n    return promise;\n  }, write);\n}\n\nexport { RESET, abortableAtom, atomFamily, atomWithDefault, atomWithHash, atomWithObservable, atomWithReducer, atomWithReset, atomWithStorage, createJSONStorage, freezeAtom, freezeAtomCreator, loadable, selectAtom, splitAtom, NO_STORAGE_VALUE as unstable_NO_STORAGE_VALUE, useAtomCallback, useHydrateAtoms, useReducerAtom, useResetAtom, waitForAll };\n"],
  "mappings": "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",
  "names": ["memoizeAtom", "atom"]
}
